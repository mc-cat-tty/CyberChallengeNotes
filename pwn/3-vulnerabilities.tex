\chapter{Vulnerabilities}
\section{Nomenclature}
 - Bug: error or fault that causes a failure
 - Error: human action that produces an incorrect result
 - Fault: incorrect step or process in a computer program (defect or flaw that can lead to a failure)
 - Failure: inability of software to perform its functions within required performance constraings (visible cause of a failure)

See: \textit{Not all that glitters is gold}

\section{Vulnerabilities classes}
 - information leakage: unintented disclosure of secret information at the end user due to security breach
 - buffer overflow
 - race condition
 - invalid data processing

\section{Memory Corruption}
Covered memory corryption attacks:
\begin{itemize}
  \item buffer overflow
  \item heap overflow
  \item shellcode injection
\end{itemize}

\subsection{Typical Errors}
Out-of-bound access, buffer overflow, reference pointing to the wrong location.

Variables overriding consists in smashing the variables allocated on the stack alongside some buffer, under user control.
This attack is used to corrupt the return address of a function.

In 64 bits binaries, the entire 64 bits address space is not used in its entirety; instead, a 48 bits (the least significant 48 bits) address space is used.

Addresses must be in \textbf{canonical form}:
\begin{itemize}
  \item From 0x0000000000000000 to 0x00007FFFFFFFFFFF -> application code
  \item From 0xFFFF800000000000 to 0xFFFFFFFFFFFFFFFF -> kernel code (not copyied, virtual mem manages it)
\end{itemize}

\subsection{Heap Corruption}
The typical objective is mangling data structures. E.g., changing point of a linked list. 

\subsection{Code Injection}
Idea: inject code using a buffer overflow and jumping to that portion of the stack. \\
Requirements: ASLR + NX (stack areas are mutually executable or writable) deactivated.

No stack canary means build with \texttt{-fno-stack-protector}.

See: PwnCollege "Shellcode Injection" and "Intermediate memory errors" training modules

Typically shellcraft is used to generate the shellcode.

In order to locate the offset between the beginning of user input (input buffer) and return address we can use de Brujin sequences.
\texttt{cyclic <num>} provides the means to inject the sequence, while \texttt{cyclic -l 0x<seq-hex>} locates the distance from input buffer start, thanks to low repeatability of the sequence.

Pwntools can be used to perform binary attacks:
\begin{verbatim}
from pwn import *

exec = ELF("<binary-name>")

payload = "a"*32  # offset
payload += p32(<target-addr>)
payload += asm(shellcraft.sh())

proc = process("./<bin-name>")
proc.sendlineafter(b'<str>', payload)

print(proc.clean()) # Clean returns the output of the process accumulated up to this point
proc.interactive()  # Give control to the user (since we opened a shell)
\end{verbatim}

\subsection{ASLR Bypass}
ASLR randomizes addresses with a granularity of 4k (virtual memory size).

\section{Format String Attacks}
First documented in the second half of 2000. See: Team Teso (2001), Format String Exploitation Tutorial by Saif El-Sherei.

Printf, scanf behaviour can be manipulated by carefully crafting format strings.
Format strings can allow to read and write values from and to the stack.

\texttt{Xprintf} and similar functions are variadic functions that take as first arg a format string.

Eg: \texttt{printf(argv[1])} prints an arbitrary string. This string can even be a format string.
Trying to pass \texttt{\%s\%s\%s} as argument, a segmentation fault will occur.
Why? Since it is a variadic function, the addresses of the 3 strings will be searched into the stack.
Printf function expects to find the values to substitute the placeholders in its internal stack.

\texttt{\%x} is the placeholder intended to print a value that has the width of a machine word, in hexadecumal format.

Modifiers can be used to alterate the length of the word: \textt{h} is the modifier for short, while \texttt{l} is the one for long.
\texttt{\%<space-num>x} prints the same number of bytes as before but aligned to \texttt{<space-num>} bytes, while \texttt{\%<num>\$<space-num>x} jumps to the num-th byte on the stack (arbitrary stack data leak).

Keep an eye on stack alignment, which depends on the underlying architecture.

Idea: once the jump location has been identified (e.g. a return address), its content can be overwritten using the \texttt{\%n} operator.

The \texttt{\%n} placeholder emits an integer value that corresponds to the number of chars prior the placeholder.
E.g. in \textit{"Hello \%n"} the number 6 is emitted. For big jumps, this is more useful \textit{"\%<num>c \%n"}.
The location where \texttt{\%n} places the value is the last address found in the last element of the variadic stack.

The idea is to generate the address we want to write on in the stack, read up to that point, then perform a \texttt{\%n}.

See: GCC fortify \\
Remember to disable ASLR