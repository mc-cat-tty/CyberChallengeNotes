\chapter{Pwn Writeups}

\section{Software Security 0}
\subsection{SS_0.01 - The safe}
Idea: password can be found in plaintext in \texttt{.rodata} section.

Run: \texttt{readelf -p .rodata the_safe}

\subsection{SS_0.02 - acrostic}
Literally: \texttt{objdump -d acrostic}

\subsection{SS_0.03 - dissection}
Idea: list all sections contained in the provided ELF file. The flag is encoded in sections name.

Run: \texttt{readelf -S dissection | grep CCI -A 17 | sed -n "p;n" | awk '{print $2}' | tr -d '\n'}

\subsection{SS_0.04 - volatility}
Idea: put a breakpoint at the beginning of one of the functions that receive the flag as argument, then print the first and only arg.

Run: \texttt{gdb --batch --command=scripts/volatility.gdb volatility}

\subsection{SS_0.05 - piecewise}
See: \textit{scripts/piecewise.py}

\section{Software Security 1}
\subsection{SS_1.01 - NextGen Safe}
Idea: the function that prints the flag is not called, however is packed into the binary (check with \texttt{readelf -p .strtab nextgen_safe}, or \texttt{info functions} inside GDB).
Sooo... just call it from GDB.

Run: \texttt{gdb --batch -x scripts/nextgen_safe.gdb nextgen_safe}

\subsection{SS_1.02 - Slow Printer}
Idea: open program in GDB and intercept every syscall to \texttt{clock_nanosleep}.
As soon as the system call is catched, set \texttt{RDX} register to \texttt{null}.
\texttt{RDX} register corresponds to \texttt{const struct timespec *t} parameter of \texttt{clock_nanosleep} function (ref. \href{https://man7.org/linux/man-pages/man2/clock_nanosleep.2.html}).

Run: \texttt{gdb --batch -x slow_printer.gdb slow_printer}

Alternatives:
\begin{itemize}
  \item skip \texttt{clock_nanosleep} calls patching the binary with NOPs (e.g., with Ghidra). See \textit{scripts/slow_printer_patched}
  \item DLL (\texttt{LD_PRELOAD}) injection
\end{itemize}

\subsection{SS_1.03 - Flag Checker}
Run code in GDB: \texttt{gdb flag_checker}.
Start it with a string as first arg: \texttt{start test}.
A SEGV will occur; backtracing it (\texttt{bt}) show an infinite recursive call.

Dissecting the binary (eg., in Ghidra) shows a function that computes the cumulative sum (stored in its third arg) of the first argument passed to the function (argv[1]).
Each character of the cumsum is tested against what presumably is each character of the flag's cumsum.
By reading the memory location where this array of integers is stored and reversing the cumsum the flag is disclosed.

See: \textit{scripts/flag_checker.py}

\subsection{SS_1.04 - Unbreakable AES}
By disassembling the code three internal functions are found \texttt{main}, \texttt{encrypt} and \texttt{ror}.

\texttt{main} function simply performs file handling operations (basically opening), as well as key validity checking (only alphanum chars).

If successful, \texttt{encrypt(<input-file>, <output-file>, <key>)} is invoked.
By carefully analyzing the disassembled code of this function, it turns out that key is not used.
The function performs right rotation of each character of the ciphertext (input file) a number of times equal to the character position plus one.

See: \textit{scripts/unbreakable_aes.py} is the script used to implement the decryption, making use of the inverse function of ror: rol -- ROtate Left.

\section{Software Security 2}
\subsection{SS_2.01 - Digital billboard}
The following snippet is the core of the challenge:
\begin{verbatim}
struct billboard {
    char text[256];
    char devmode;
};
struct billboard bb = { .text="Placeholder", .devmode=0 };

void set_text(int argc, char* argv[]) {
    strcpy(bb.text, argv[1]);
    printf("Successfully set text to: %s\n", bb.text);
    return;
}
\end{verbatim}

Using \texttt{strcpy} is inherently unsafe.
By maliciously manipulating the input string, \texttt{devmode} flag can be flipped.
The value of \texttt{text} is comnpletely under the user's input: \texttt{'a'*257} is enough to overflow the allocated buffer, thus turning \texttt{devmode} into \texttt{'a'}, which is 1 under boolean perspective.

\subsection{SS_2.02 - 1996}
Objective: change control flow to run the \texttt{spawn_shell} function.

\texttt{cin} function allows stack smashing, and PIE is disabled, making it impossible for the kernel to enable ASLR.
\texttt{spawn_shell} address can be found from the symbol table: \texttt{objdump -t 1996 | grep "spawn"}.
The address is 64-bits long, like \texttt{file 1996} confirms.

Reversing the binary allows us to understand the offset of the stored RIP in \texttt{main}'s stack: 1048 bytes from buffer's base address.
By filling the stack with 1048 bytes of padding and appeding the desired address (\textit{0000000000400897}) at the end of the payload, the challenge is solved.

See: \textit{scripts/1996.py}

\subsection{SS_2.03 - the answer}
Objective: change the value of \texttt{the_answer} variable in \texttt{.data} section, replacing its content with the value 42.

From the application source code, call to \texttt{printf} with arbitrary user input can be noticed.
The user input is fed to the function as a first argument, thus enabling format strings interpretation.
A format string attack is therefore chosen.

Address of the variable is extracted from the symbol table: \texttt{objdump -t the_answer | grep answer}. \\
Result: \textit{0x0000000000601078}

Solution#1: \texttt{python3 -c 'import sys; from pwn import p32; sys.stdout.buffer.write(b"\%42c\%12\$ln".ljust(16, b"A") + p32(0x0000000000601078).ljust(8, b"\0") + b"\n")' | ./the_answer}
Solution#2: \texttt{python3 -c 'import sys; from pwn import p32; sys.stdout.buffer.write(b"AAAAAA\%36c\%12\$ln" + p32(0x0000000000601078).ljust(8, b"\0") + b"\n")'}

The attack consists in writing 42 bytes, then jumping to printf variadic stack that contains the target address, writing emitted bytes/chars (42) in that location with \texttt{\%12\$ln}.

\subsection{SS_2.04 - restricted shell}
Objective: get an unrestricted shell on the target machine.

Preliminary analysis: it can be noticed (with \texttt{checksec}) that the binary has all security measures turned off, especially the NX flag. \\
Performing a static analysis on the binary reveals that \texttt{shell()} functions allocate a buffer of 40 bytes and write user's input in it, with an unbounded function (\texttt{gets}). \\
The application terminates its execution if the passed command does not match \texttt{ls} or \texttt{dir}; if that's the case, then the function returns with an error message. \\

Given the unsecure nature of \texttt{gets} a buffer overflow can be performed, with the intermediate objective of overwriting the return address of the function. \\
The static analysis also reveals that a "gadget" | \texttt{jmp esp} | is placed at the end of the function. This instruction (combined with the fact that NX is disabled) allows us to move control flow to the stack. \\

This scenario leads to an attack that exploits the buffer overflow to redirect execution towards the gadget, which in turn executes user-controlled input on the stack, where a shellcode will be placed.

It is also worth noticing that before the \texttt{ret} instruction, a \texttt{leave} is present, which changes the esp-ebp "configuration" in the midst of the attack.

The final pyaload is crafted as follows:
\begin{itemize}
  \item 44 bytes of padding -- some NOPs has been used, but even non-valid opcodes are ok. This offset can be found either by hand (static analysis) or with \texttt{pwn cyclic} (dynamic analysis).
  \item the target address -- aka the address of the gadget.
  \item the shellcode (which, after the leave+ret, will be found at the head of the stack)
\end{itemize}

See: \textit{scripts/restricted_shell.py}

\subsection{SS_2.05 - LMRTFY}
The input buffer is executable and gets executed in \texttt{main} function.
System calls are blacklisted by \texttt{memmem} functions which search 3 needles (\texttt{int 80}, \texttt{syscall}, \texttt{sysenter}) in input buffer.

Idea: use a standard shellcode to open a shell, replacing \texttt{int 80} with an absolute jump (actually, a push and ret) to an instruction that performs it, a "gadget".

See: \textit{scripts/lmrtfy.py}
